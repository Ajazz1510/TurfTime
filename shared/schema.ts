import { pgTable, text, serial, integer, boolean, timestamp, pgEnum, jsonb, doublePrecision } from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
import { z } from "zod";

// Define user roles
export const userRoleEnum = pgEnum("user_role", ["customer", "owner"]);

// Define sports types
export const sportTypeEnum = pgEnum("sport_type", ["cricket", "football", "badminton"]);

// Define booking status 
export const bookingStatusEnum = pgEnum("booking_status", ["pending", "confirmed", "cancelled", "completed"]);

// Users table
export const users = pgTable("users", {
  id: serial("id").primaryKey(),
  username: text("username").notNull().unique(),
  password: text("password").notNull(),
  email: text("email").notNull().unique(),
  fullName: text("full_name").notNull(),
  role: userRoleEnum("role").notNull().default("customer"),
  // For turf owners
  businessName: text("business_name"),
  phone: text("phone"),
  address: text("address"),
  city: text("city"),
  createdAt: timestamp("created_at").defaultNow(),
});

// Turfs table
export const turfs = pgTable("turfs", {
  id: serial("id").primaryKey(),
  ownerId: integer("owner_id").notNull(),
  name: text("name").notNull(),
  description: text("description"),
  sportType: sportTypeEnum("sport_type").notNull(),
  maxPlayers: integer("max_players").notNull(), // Maximum number of players allowed
  duration: integer("duration").notNull(), // in minutes
  price: integer("price").notNull(), // in rupees (INR)
  amenities: jsonb("amenities").default({}).notNull(),
  location: text("location"),
  imageUrl: text("image_url"),
  latitude: doublePrecision("latitude"), // Geographic coordinates
  longitude: doublePrecision("longitude"), // Geographic coordinates
});

// Available slots table
export const slots = pgTable("slots", {
  id: serial("id").primaryKey(),
  ownerId: integer("owner_id").notNull(),
  turfId: integer("turf_id").notNull(), // Renamed from serviceId
  startTime: timestamp("start_time").notNull(),
  endTime: timestamp("end_time").notNull(),
  isBooked: boolean("is_booked").default(false),
});

// Bookings table
export const bookings = pgTable("bookings", {
  id: serial("id").primaryKey(),
  serviceId: text("service_id"), // Unique service ID for customer reference (optional, generated by server)
  customerId: integer("customer_id").notNull(),
  ownerId: integer("owner_id").notNull(),
  turfId: integer("turf_id").notNull(), // Renamed from serviceId
  slotId: integer("slot_id").notNull(),
  status: bookingStatusEnum("status").notNull().default("pending"), 
  teamName: text("team_name").notNull(), // Team name is required for turf bookings
  playerCount: integer("player_count").notNull(), // Number of players in booking
  mobileNumber: text("mobile_number"), // Mobile number for contact (optional for backward compatibility)
  bookingStartTime: timestamp("booking_start_time"), // Custom start time within the slot
  bookingEndTime: timestamp("booking_end_time"), // Custom end time within the slot
  notes: text("notes"),
  createdAt: timestamp("created_at").defaultNow(),
});

// Insert schemas
export const insertUserSchema = createInsertSchema(users).omit({ id: true, createdAt: true });
export const insertTurfSchema = createInsertSchema(turfs, {
  latitude: z.number().min(-90).max(90).optional().nullable(),
  longitude: z.number().min(-180).max(180).optional().nullable(),
}).omit({ id: true });
// Create the slot schema with proper date transformation
export const insertSlotSchema = createInsertSchema(slots, {
  startTime: z.string().or(z.date()).transform(val => 
    typeof val === 'string' ? new Date(val) : val
  ),
  endTime: z.string().or(z.date()).transform(val => 
    typeof val === 'string' ? new Date(val) : val
  ),
}).omit({ id: true });
// Enhanced booking schema with more detailed validation and better date handling
export const insertBookingSchema = createInsertSchema(bookings, {
  serviceId: z.string().optional(), // Allow the backend to generate this
  teamName: z.string().min(2, "Team name must be at least 2 characters"),
  playerCount: z.number().int().positive("Player count must be a positive number"),
  mobileNumber: z.string().min(10, "Mobile number must be at least 10 digits").optional(),
  status: z.enum(bookingStatusEnum.enumValues, {
    errorMap: () => ({ message: `Status must be one of: ${bookingStatusEnum.enumValues.join(', ')}` })
  }),
  bookingStartTime: z.union([
    z.string().refine(val => !isNaN(Date.parse(val)), {
      message: "Invalid date format for booking start time"
    }).transform(val => new Date(val)),
    z.date()
  ]),
  bookingEndTime: z.union([
    z.string().refine(val => !isNaN(Date.parse(val)), {
      message: "Invalid date format for booking end time"
    }).transform(val => new Date(val)),
    z.date()
  ]),
  notes: z.string().optional(),
}).omit({ id: true, createdAt: true });

// Insert types
export type InsertUser = z.infer<typeof insertUserSchema>;
export type InsertTurf = z.infer<typeof insertTurfSchema>;
export type InsertSlot = z.infer<typeof insertSlotSchema>;
export type InsertBooking = z.infer<typeof insertBookingSchema>;

// Convenience booking type with string dates for API calls
export type BookingRequest = Omit<InsertBooking, 'bookingStartTime' | 'bookingEndTime'> & {
  bookingStartTime: string;
  bookingEndTime: string;
};

// Select types
export type User = typeof users.$inferSelect;
export type Turf = typeof turfs.$inferSelect;
export type Slot = typeof slots.$inferSelect;
export type Booking = typeof bookings.$inferSelect;

// Login schema (for validation)
export const loginSchema = z.object({
  username: z.string().min(3, "Username must be at least 3 characters"),
  password: z.string().min(6, "Password must be at least 6 characters"),
});

export const registerSchema = insertUserSchema.extend({
  confirmPassword: z.string()
}).refine(data => data.password === data.confirmPassword, {
  message: "Passwords don't match",
  path: ["confirmPassword"]
});

export const profileSchema = z.object({
  fullName: z.string().min(3, "Full name must be at least 3 characters"),
  email: z.string().email("Invalid email address"),
  phone: z.string().optional().nullable(),
  businessName: z.string().optional().nullable(),
  address: z.string().optional().nullable(),
  city: z.string().optional().nullable(),
});

export type LoginCredentials = z.infer<typeof loginSchema>;
